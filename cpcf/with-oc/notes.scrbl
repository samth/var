#lang scribble/lncs
@(require (only-in scribble/manual racketmod)
          slideshow/pict
          redex/pict
          "lang.rkt"
          "machine.rkt"
          "judgment.rkt"
          scriblib/figure)

@section{Previously problematic programs}

Basically programs not guided by appropriate disjunctive contracts.
@verbatim[#:indent 4]{
                      
(module
 (provide [f (any/c ↦ any/c)])
 (define (f x)
   (if (cons? x) (car x) x)))
   
}
Another example is the expression generated by @tt{FC(cons/c c1 c2)} in the paper.
@verbatim[#:indent 4]{
                      
(FC (C1 C2)) = (λ (y) (and (cons? y)
                           ((FC C1) (car y))
                           ((FC C2) (cdr y))))
                           
}
Also, it's useful to remember results from testing arbitrary expressions. For example, @tt{lastpair} from the Wright paper
@verbatim[#:indent 4]{

; cons? → cons?
(λ (s)
  (if (cons? (cdr s))
      (lastpair (cdr s))
      s))
      
}

@section{Language}

Untyped λ-calculus augmented with
@itemlist[
  @item{based values of integers, strings, @tt{#t}, @tt{#f}
        , primitive operations, pairs}
  @item{contracts}
  @item{abstract values refinable by contracts}
  @item{syntactic sugar for @tt{cond}, @tt{and}, @tt{or}, @tt{let}, and @tt{begin}}
]
Labels are omitted for @tt{mon} and @tt{blame}.

@(centered (parameterize ([render-language-nts '(e a v op o1 o2 p? ψ c ρ O Γ o o′ acc C V CC)])
             (render-language scpcf)))

There is no explicit representation for union types.
Instead, non-determinism is used for better precision.
One example to illustrate this is from the Chugh paper.
Instead of returning @tt{(∪ int? bool?)},
this function returns an @tt{int?} or @tt{bool?}
in different non-deterministic branches.

@verbatim[#:indent 4]{
(λ (x)
  (cond
    [(int? x) (- 0 x)]
    [(bool? x) (false? x)])
}

Γ is the proposition environment, mapping each path to a set of predicates.

@verbatim[#:indent 4]{
[o ↦ ψ1 ψ2 ...]
}
means
@verbatim[#:indent 4]{
(ψ1(o) ∧ ψ2(o) ∧ ...)
}

@section{Big-step semantics}

@verbatim[#:indent 4]{
Γ ⊢ C ⇓ V; Γ′; o
}
means under assumptions @tt{Γ}, closure @tt{C} evaluates to @tt{V}, resulting in new set of propositions @tt{Γ′} with no less information than @tt{Γ}.

Invariants:
@itemlist[
  @item{@tt{Γ}, @tt{C} and @tt{Γ′} have the same domain.
        (The metafunction @tt{dom} is also conveniently 'overloaded'
        on closures (partially), discussed later).}
  @item{@tt{dom(C)[o]} is @tt{V}, if @tt{dom(C)} is defined}
  @item{Whatever @tt{Γ′} knows that's relevant to @tt{V}
        has already been incorporated in @tt{V}}
]

@subsection{Value}
Closed value @tt{V} evaluates to itself, probably with all interesting propositions
from @tt{Γ} flushed into its environment.

@(centered (parameterize ([judgment-form-cases '("val")])
             (render-judgment-form ⇓)))

@tt{flush} converts all relevant propositions from @tt{Γ} into contracts to refine
free variables in @tt{V}'s environment. The following example illustrates why this
is helpful. This expression should always returns @tt{#t}
@verbatim[#:indent 4]{
(int? [(let [x •]
         (if (int? x)
             (λ (_) x)
             (λ (_) 1)))
       •])
}
By the time the @tt{(let ...)} part is done,
all propositions about @tt{x} will have already been 'popped' out from Γ.
We need a way to remember that @tt{x} is an @tt{int?} in @tt{(λ (_) x)}.
This was not a problem with type-checking because we could look through @tt{λ}
and say it was of type @tt{(any? → int?)} once and for all.

@subsection{Variable}
If @tt{x} maps to closed value @tt{V},
this is the last chance to refine it with propositions from @tt{Γ}.
For example, @tt{Γ} knows @tt{[(car x) ↦ int?]}, and @tt{x}
maps to @tt{•}, then we know it evaluates to @tt{(• / (cons/c int? any/c))}.
@(centered (parameterize ([judgment-form-cases '("var")])
             (render-judgment-form ⇓)))
This may makes it tempting to combine @tt{Γ} and @tt{ρ} into 1 environment,
but I tried this and it would be awkward to communicate back and forth
when we want to say "Evaluating the @tt{nth} argument gives back this
proposition of interest to arguments @tt{1} through @tt{n-1}.
It's useful to have @tt{Γ} as a global 'scratch space'.

@tt{x} may also map to @tt{(μ (z) ...)}
@(centered (parameterize ([judgment-form-cases '("var-μ")])
             (render-judgment-form ⇓)))

@subsection{Application}
This is the most tricky, ugly, and potentially inefficient part.
The domains for @tt{Γ}'s need correct maintenance to prevent
spurious results.

@subsubsection{λ-abstraction}
I need some flexibility later, so I factor out the rule that
explicitly deals with the application closure.
@(centered (parameterize ([judgment-form-cases '("app-λ-raw")])
             (render-judgment-form ⇓)))
@(centered (parameterize ([judgment-form-cases '("app-λ")])
             (render-judgment-form ⇓)))

Helper metafunctions:
@itemlist[
  @item{@tt{mk-Γ(X, Γ)} makes a new environment with domain X
        that knows everything Γ knows in X}
  @item{@tt{upd-Γ(Γ1, Γ2)} returns @tt{Γ1} updated with all
        @tt{Γ2} knows in @tt{Γ1}'s domain}
  @item{@tt{push(Γ, x)} extends @tt{Γ}'s domain to include @tt{x}.
        If @tt{Γ} already has non-trivial propositions on @tt{x},
        they're invalidated. So no matter what, @tt{[x ↦ tt]}}
  @item{@tt{pop(Γ, x)} removes @tt{x} from @tt{Γ}'s domain.}
  @item{@tt{mb(o, X)} returns path @tt{o} if it's made from a variable
        in @tt{X}, otherwise @tt{∅}}
  @item{@tt{default-o(o, o′)} returns @tt{o} if it's not @tt{∅}, otherwise @tt{o′}}
]

@subsubsection{Monitored function}
The 1st rule could be merged with that in previous section.
I just don't know how to say "where X or Y matches Z"
in redex.
@(centered (parameterize ([judgment-form-cases '("app-mon-raw")])
             (render-judgment-form ⇓)))
Monitor argument, apply function, then monitor result:
@(centered (parameterize ([judgment-form-cases '("app-mon")])
             (render-judgment-form ⇓)))

@subsubsection{Primitive operation}
@verbatim[#:indent 4]{
δ : op (V o) ... Γ -> (V Γ o)
}

This is where useful propositions are added to @tt{Γ}.

@tt{δ} takes @tt{Γ} as an argument not because @tt{Γ} helps
knowing more about the arguments (they have already been
fully refined at this point), but because it needs to also return
information discovered/assumed for arguments and result.

For example, when adding @tt{x} and @tt{y} given @tt{[x ↦ •, y ↦ •]},
δ non-deternimistically assumes @tt{x} and @tt{y} are integers in one branch
and remembers that fact in @tt{Γ}.

If @tt{o1} happens to be a predicate @tt{p?},
whether the argument fails or passes this predicate is remembered.
@(centered (parameterize ([judgment-form-cases '("app-o1")])
             (render-judgment-form ⇓)))
@(centered (parameterize ([judgment-form-cases '("app-o2")])
             (render-judgment-form ⇓)))

@subsection{Conditional}
(Uninteresting)
@(centered (parameterize ([judgment-form-cases '("if-true")])
             (render-judgment-form ⇓)))
@(centered (parameterize ([judgment-form-cases '("if-false")])
             (render-judgment-form ⇓)))

@subsection{Monitored expression}
I factor out the rule for monitoring a contract on a value also for flexibility.
@(centered (parameterize ([judgment-form-cases '("mon-raw")])
             (render-judgment-form ⇓)))

@subsubsection{Flat contract}
@(centered (parameterize ([judgment-form-cases '("mon-flat")])
             (render-judgment-form ⇓)))

@subsubsection{and/c}
@(centered (parameterize ([judgment-form-cases '("mon-and/c")])
             (render-judgment-form ⇓)))

@subsubsection{or/c}
@(centered (parameterize ([judgment-form-cases '("mon-or/c-1")])
             (render-judgment-form ⇓)))
@(centered (parameterize ([judgment-form-cases '("mon-or/c-2")])
             (render-judgment-form ⇓)))

@subsubsection{cons/c}
@(centered (parameterize ([judgment-form-cases '("mon-cons/c")])
             (render-judgment-form ⇓)))

@section{Machine semantics}

Machine state:  @(parameterize ([render-language-nts '(ς)])
                   (render-language scpcf-m))

The judgment form
@verbatim[#:indent 4]{
Γ ⊢ C ⇓ V Γ′ o
}
corresponds to
@verbatim[#:indent 4]{
(C ∅ Γ κ) →* (V o Γ′ κ)
}, whatever @tt{κ} is, I think.

For each big-step rule of the form
@verbatim[#:indent 4]{
Γ1 ⊢ C1 ⇓ ...
...
------------------------
Γ ⊢ C ⇓ V Γ′ o
}
I make @tt{(C ∅ Γ κ)} change to @tt{(C1 Γ1 ∅ κ′)},
with @tt{κ′} being @tt{κ} with appropriate frame(s) on top
to make sure the state eventually changes to @tt{(V Γ′ o κ)}.

Continuation
@(centered (parameterize ([render-language-nts '(κ)])
             (render-language scpcf-m)))
is mostly standard, with 2 weird frames:

@verbatim[#:indent 4]{
(with-V (V o) κ)
} replaces @tt{V} and @tt{o} for those in current state.
I need this when monitoring @tt{cons/c c1 c2},
where I monitor it's @tt{car},
swap its @tt{cdr} in, monitor,
then put back @tt{(cons (V1 / c1) (V2 / c2))}.
 
This frame
@verbatim[#:indent 4]{
(with-Γ Γ′ x o′ κ)
} replaces current proposition environment @tt{Γ} with
@tt{upd(Γ′, pop(Γ, x))}.
The current object @tt{o} is also replaced with @tt{o′}.
This frame does 2 things because it's easier to preseve tail-calls
this way instead of having interleaving frames of @tt{with-Γ}
and @tt{with-o}, say.

@subsection{Distribution}
@(centered (parameterize ([render-reduction-relation-rules '(mon-distr)])
             (render-reduction-relation red #:style 'compact-vertical)))

@subsection{On non-value}
Appropriate continuation frames are added
@(centered (parameterize ([render-reduction-relation-rules
                           '(var var-μ app-intro if-intro μ mon-intro)])
             (render-reduction-relation red #:style 'compact-vertical)))

@subsection{On value}
Appropriate rule for top frame is applied
@(centered (parameterize ([render-reduction-relation-rules
                           '(app-swap app-λ app-op app-mon if-true if-false
                                      mon-flat mon-and/c mon-or/c mon-cons/c
                                      mon-x mon-μ with-V with-Γ err)])
             (render-reduction-relation red #:style 'compact-vertical)))

@section{Appendix: Metafunctions}

@subsection{dom}
@verbatim{
dom : (ρ | Γ | C) -> {x ...}
returns domain for environment, monitored value, or non-pair closure.
}
@(render-metafunctions dom var-from-path)

@subsection{acc-o}
@verbatim{
acc-o : acc o -> o
prepends another accessor to given path.
accessor is just (car|cdr) for now.
}
@(render-metafunction acc-o)