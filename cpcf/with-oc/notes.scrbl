#lang scribble/lncs
@(require (only-in scribble/manual racketmod)
          slideshow/pict
          redex/pict
          "lang.rkt"
          "machine.rkt"
          "judgment.rkt"
          scriblib/figure)

@section{Previously problematic programs}

Basically programs not guided by appropriate disjunctive contracts.

@verbatim[#:indent 4]{
                      
(module
 (provide [f (any/c ↦ any/c)])
 (define (f x)
   (if (cons? x) (car x) x)))
   
}

Another example is the expression generated by @tt{FC(cons/c c1 c2)} in the paper.

@verbatim[#:indent 4]{
                      
(FC (C1 C2)) = (λ (y) (and (cons? y)
                           ((FC C1) (car y))
                           ((FC C2) (cdr y))))
                           
}

@section{Language}

Similar to @tt{S-CPCF} from paper, with syntactic sugar for
@tt{and}, @tt{or}, @tt{let}, @tt{begin}, and @tt{cond}.
Labels are omitted for @tt{mon} and @tt{blame}.

@(centered (parameterize ([render-language-nts '(e a v op o1 o2 p? ψ c ρ O Γ o o′ acc C V CC)])
               (render-language scpcf)))

There is no explicit representation for union types.
Instead, non-determinism is used for better precision.
One example to illustrate this is from the Chugh paper.
Instead of returning @tt{(∪ int? bool?)},
this function returns an @tt{int?} or @tt{bool?}
in different non-deterministic branches.

@verbatim[#:indent 4]{
                      
(λ (x)
  (cond
    [(int? x) (- 0 x)]
    [(bool? x) (false? x)])
    
}

Γ is the proposition environment, mapping each path to a set of predicates.
@tt{[o ↦ ψ1 ψ2 ...]} means @tt{((ψ1 o) ∧ (ψ2 o) ∧ ...)}.

@section{Big-step semantics}

Not really readable. I don't know how to customize the layout. Looks like
the @tt{#:style} thing is not available for @tt{render-judgment-form}...

@(render-judgment-form ⇓)

@section{Machine semantics}

Machine state
@(parameterize ([render-language-nts '(ς)])
   (render-language scpcf-m))

@(render-reduction-relation red #:style 'compact-vertical)

@section{Appendix: metafunctions}

@subsection{Evaluation based on big-step semantics}

This is not really readable because I escaped to Racket to
define convenient syntax to handle non-determinism that automatically
propagated errors and removed duplicates. For example:
@verbatim{
(non-det:
  [V′ Γ′ o ← (step Γ C)]
  [...])
}
means closure @tt{C} under @tt{Γ} non-deterministically evaluates to
@tt{(V′ Γ′ o)}, then stuff in @tt{[...]} are performed separately
for each branch (if there's more than 1).

The first 12 rules are just for syntactic sugar.

@verbatim{
step : Γ C -> {A ...} , where A ::= (V Γ o)
                                  | ERR
}
@(render-metafunction step)

@subsection{Proposition environment manipulation}

@verbatim{
push : Γ x -> Γ
resets all propositions refering to x
e.g. (push ([(car x) ↦ str?] [z ↦ int?]) x) → ([x ↦ tt] [z ↦ int?])
}

@verbatim{
pop : Γ x -> Γ
removes x from environment's domain
e.g. (pop ([(car x) ↦ str?] [z ↦ int?]) x) → ([z ↦ int?])
}

@verbatim{
mk-Γ : {X ...} Γ -> Γ
makes environment with given domain and join with Γ
e.g. (mk-Γ {x} ([x ↦ cons?] [(car x) ↦ str?] [z ↦ int?]))
     → ([x ↦ cons?] [(car x) ↦ str?])
}

@verbatim{
upd-Γ : Γ Γ -> Γ
uses 2nd environment to refine 1st one in their common domain
}