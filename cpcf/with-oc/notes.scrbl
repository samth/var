#lang scribble/lncs
@(require (only-in scribble/manual racketmod)
          slideshow/pict
          redex/pict
          (only-in "lang-simple.rkt" [⇓ ⇓s] [⇓c ⇓cs] [APP APP-s] [MON MON-s] cpcf)
          "lang.rkt"
          "machine.rkt"
          "judgment.rkt"
          scriblib/figure)

@section{Previously problematic programs}

The system was insensitive to conditionals and relied solely
on the right disjunctive contracts for function arguments.

For example, this module worked:
@verbatim[#:indent 4]{
                      
(module
  (provide [maybe-head ((μ (list/c) (or/c nil? (cons/c any/c list/c)))
                        ↦ any/c)])
  (define (maybe-head l)
    (if (cons? l) (car l) nil)))
    
}
But this didn't:
@verbatim[#:indent 4]{
                      
(module
 (provide [maybe-head (any/c ↦ any/c)])
 (define (maybe-head l)
   (if (cons? l) (car l) nil)))
   
}
Another example is the expression generated by @tt{FC(cons/c c1 c2)} in the paper.
@verbatim[#:indent 4]{
                      
(FC (C1 C2)) = (λ (y) (and (cons? y)
                           ((FC C1) (car y))
                           ((FC C2) (cdr y))))     
                           
}
Also, it's useful to remember results from testing arbitrary expressions.
For example, @tt{lastpair} from the Wright paper
@verbatim[#:indent 4]{
                      
; cons? → cons?
(λ (s)
  (if (cons? (cdr s))
      (lastpair (cdr s))
      s))
      
}

@section{CPCF}
The language is mostly similar to @tt{CPCF} from the paper.
Main differences are:
type checking is skipped with terms assumed well-typed,
and labels are omitted for monitoring.

The language's semantics is defined by
2 relations @tt{⇓}, @tt{⇓c}, and 2 metafunctions @tt{APP}, @tt{MON},
for expression evaluation, contract evaluation, closure application,
and closure monitoring, respectively.

@subsection{Syntax}
@(centered (parameterize
               ([render-language-nts '(e v b op o1 o2 p? c ρ ψ V D Ans Dns CC Cns)])
             (render-language cpcf)))
(@tt{tt} is the constant true function.
@tt{CC} is closed, unevaluated contract.)

@subsection{Expression big-step semantics}
@verbatim[#:indent 4]{
ρ, ψ ⊢ e ⇓ Ans
}

@tt{Ans} is either a closed value or @tt{ERR}.
(@tt{ERR} is returned with more information in the next section.)

@subsubsection{Value}
@(centered (parameterize ([judgment-form-cases '("val")])
             (render-judgment-form ⇓s)))
@subsubsection{Variable}
@(centered (parameterize ([judgment-form-cases '("var")])
             (render-judgment-form ⇓s)))
@subsubsection{Application}
@(centered (parameterize ([judgment-form-cases '("app" "app-err")])
             (render-judgment-form ⇓s)))
@subsubsection{Conditional}
@(centered (parameterize ([judgment-form-cases '("if-true" "if-false" "if-err")])
             (render-judgment-form ⇓s)))
@subsubsection{Rec}
@(centered (parameterize ([judgment-form-cases '("μ")])
             (render-judgment-form ⇓s)))
@subsubsection{Monitored expressions}
@(centered (parameterize ([judgment-form-cases '("mon" "mon-c-err" "mon-e-err")])
             (render-judgment-form ⇓s)))

@subsection{Contract big-step semantics}
@verbatim[#:indent 4]{
ρ, ψ ⊢ c ⇓ Dns
}
@subsubsection{Flat contract}
@(centered (parameterize ([judgment-form-cases '("flat" "flat-err")])
             (render-judgment-form ⇓cs)))
@subsubsection{Disjunctive, conjunctive, pair, function contracts}
Composite contracts are delayed because evaluating recursive contracts
may proceed forever.
@(centered (parameterize ([judgment-form-cases '("or/c" "and/c" "cons/c" "func/c")])
             (render-judgment-form ⇓cs)))
@subsubsection{Recursive contract}
Recursive contracts are unrolled then evaluated.
@(centered (parameterize ([judgment-form-cases '("μ/c")])
             (render-judgment-form ⇓cs)))
@subsubsection{Contract reference}
(A contract reference is only introduced by some recursive contract)
@(centered (parameterize ([judgment-form-cases '("x/c")])
             (render-judgment-form ⇓cs)))

@subsection{Closure application}
@verbatim[#:indent 4]{
APP : V V ... -> Ans
}
@(centered (render-metafunction APP-s))

@subsection{Closure monitoring}
@verbatim[#:indent 4]{
MON : Cns Ans -> Cns
}
@tt{MON} takes as its first argument a contract that's potentially unevaluated.
This is to factor out the task of closing and evaluating sub-contracts for
@tt{or/c}, @tt{and/c}, and @tt{cons/c}.
Also, arguments are @tt{Cns} and @tt{Ans} instead of @tt{D} and @tt{V}
to help propagating errors.
@(centered (render-metafunction MON-s))

@section{Symbolic Core Racket}

@subsection{Syntax}
Compared to @tt{CPCF}, this language has symbolic values refinable by contracts.

@(centered (parameterize ([render-language-nts '(v φ O Γ o o′ acc C V D)])
             (render-language scpcf)))

There is no explicit representation for union types.
Instead, non-determinism is used for better precision.
In this example from the Chugh paper,
instead of returning @tt{(∪ int? bool?)},
this function returns an @tt{int?} or @tt{bool?}
in different non-deterministic branches.
@verbatim[#:indent 4]{
                      
(λ (x)
  (cond
    [(int? x) (- 0 x)]
    [(bool? x) (false? x)])
    
}

Γ is the proposition environment, mapping each path to a set of predicates.

@verbatim[#:indent 4]{
                      
[o′ ↦ ψ1 ψ2 ...]

}
means
@verbatim[#:indent 4]{
                      
(ψ1(ρ[o′]) ∧ ψ2(ρ[o′]) ∧ ...)

}, where @tt{ρ} is the run-time environment,
and path lookup in @tt{ρ} is defined as
@verbatim[#:indent 4]{
ρ[(x)] = ρ[x] (with regular definition of variable lookup)
ρ[(acc_1 acc_2 ... x)] = acc_1(ρ[(acc_2 ... x)])
}

The language's semantics is defined by 4 relations:
@tt{⇓}, @tt{⇓c}, @tt{⇓a}, @tt{⇓m},
for expression evaluation, contract evaluation, closure application,
and closure monitoring, respectively.
Due to non-determinism when dealing with abstract values,
I turn the metafunctions @tt{MON} and @tt{APP} from the previous section
into relations @tt{⇓a} and @tt{⇓m}.

@verbatim[#:indent 4]{
                      
Γ, ρ, O, ψ ⊢ e ⇓ Ans; Γ′; o
Γ, ρ, O, ψ ⊢ c ⇓c Dns; Γ′
Γ ⊢ V ((V o) ...) ⇓a Ans; Γ′; o
Γ ⊢ D (V o) ⇓m Ans; Γ′
         
}

@subsection{Expression big-step semantics}

@verbatim[#:indent 4]{
                      
Γ, ρ, O, ψ ⊢ e ⇓ Ans; Γ′; o

}
means under assumptions @tt{Γ}, expression @tt{e}, closed by environment @tt{ρ},
evaluates to answer @tt{Ans}, resulting in a new set of propositions @tt{Γ′}
with no less information than @tt{Γ}.

Invariants:
@itemlist[
  @item{@tt{dom(ρ)} = @tt{dom(O)} = @tt{dom(Γ)} = @tt{dom(Γ′)},
        where @tt{dom} is defined in Appendix.}
  @item{If @tt{Ans} = @tt{V} and @tt{o} ≠ @tt{∅}, then @tt{ρ[o]} is @tt{V}}
  @item{If @tt{Ans} = @tt{V}, whatever @tt{Γ′} knows that's relevant to @tt{V}
        has already been incorporated in @tt{V}}
]

@subsubsection{Value}
We turn propositions in @tt{Γ} into contracts refining variables
in @tt{ρ} on closing @tt{v}.
@(centered (parameterize ([judgment-form-cases '("val")])
             (render-judgment-form ⇓)))
The metafunction @tt{flush} updates @tt{ρ} with propositions from @tt{Γ}
@verbatim[#:indent 4]{
                      
flush : Γ ρ -> ρ

}
The following example illustrates why this is helpful.
This expression should always return @tt{#t}
@verbatim[#:indent 4]{
                      
(int? [(let [x •]
         (if (int? x)
             (λ (_) x)
             (λ (_) 1)))
       •])
       
}
By the time the @tt{(let ...)} part is done, all propositions on @tt{x}
will have been 'popped' out from @tt{Γ}.
We need a way to remember that @tt{x} is @tt{int?} in @tt{(λ (_) x)}.
This was not a problem with type-checking because we could look through @tt{λ}
and say it was of type @tt{(any? → int?)} once and for all.

@subsubsection{Variable}
If @tt{x} maps to closed value @tt{V}, this is the last chance to refine it
with propositions from @tt{Γ}.
For example, @tt{Γ} knows @tt{[(car x) ↦ int?]}, and @tt{x} maps to @tt{•},
then we know it evaluates to @tt{• / (cons/c int? any/c)}.
@(centered (parameterize ([judgment-form-cases '("var")])
             (render-judgment-form ⇓)))

The metafunction @tt{Γ-refine} refines @tt{x} with all relevant
propositions on @tt{O[x]}.
@verbatim[#:indent 4]{
                      
Γ-refine : V Γ o -> V

}

@subsubsection{Application}
The threading of proposition environments prevents me from making the rules more succinct
as in the previous section...
@(centered
  (parameterize 
      ([judgment-form-cases '("app-1" "app-2" "app-err1" "app-err2" "app-err3")])
    (render-judgment-form ⇓)))

@subsubsection{Conditional}
@(centered (parameterize ([judgment-form-cases '("if-true" "if-false" "if-err")])
             (render-judgment-form ⇓)))

@subsubsection{Rec}
@(centered (parameterize ([judgment-form-cases '("μ")])
             (render-judgment-form ⇓)))

@subsubsection{Monitored expressions}
@(centered (parameterize ([judgment-form-cases '("mon" "mon-c-err" "mon-e-err")])
             (render-judgment-form ⇓)))

@subsection{Contract big-step semantics}
@verbatim[#:indent 4]{
                      
Γ, ρ, O, ψ ⊢ c ⇓c Dns; Γ′

}
means under assumptions @tt{Γ}, contract @tt{c},
closed by environment @tt{ρ}, evaluates to answer @tt{Dns},
resulting in a new set of propositions @tt{Γ′}
with no less information than @tt{Γ}.
The same invariant about environments' domains holds
for @tt{ρ}, @tt{O}, @tt{Γ}, @tt{Γ′}, and whatever @tt{Γ′} knows that's
relevant to @tt{D} (if @tt{Dns} = @tt{D}) has already been 'flushed'
into its environment.

@subsubsection{Flat contract}
@(centered (parameterize ([judgment-form-cases '("flat/c" "flat/c-err")])
             (render-judgment-form ⇓c)))
@subsubsection{Disjunctive, conjunctive, pair, function contracts}
@(centered (parameterize
               ([judgment-form-cases '("or/c" "and/c" "cons/c" "func/c")])
             (render-judgment-form ⇓c)))
@subsubsection{Recursive contract}
@(centered (parameterize ([judgment-form-cases '("μ/c")])
             (render-judgment-form ⇓c)))
@subsubsection{Contract reference}
@(centered (parameterize ([judgment-form-cases '("x/c")])
             (render-judgment-form ⇓c)))

@subsection{Closure application}
@verbatim[#:indent 4]{
                      
Γ ⊢ V ((V o) ...) ⇓a Ans; Γ′; o

}
Invariants: @tt{Γ} and @tt{Γ′} have the same domain,
and all path objects @tt{o}'s are in this domain if they're not @tt{∅}.

@subsubsection{Lambda}

Application is where @tt{Γ}'s domain needs maintenance
to be in sync with the new environment.
@(centered (parameterize ([judgment-form-cases '("app-λ")])
             (render-judgment-form ⇓a)))
Metafunctions:
@itemlist[
  @item{@tt{Γ-reset : Γ x -> Γ} : extends @tt{Γ}'s domain to include @tt{x}
         , mapping it to the trivial predicate @tt{tt}.
         All previous propositions in @tt{Γ} involving paths derived from @tt{x}
         are discarded.}
  @item{@tt{Γ-del : Γ x -> Γ} : removes @tt{x} from @tt{Γ}'s domain.}
  @item{@tt{Γ-mk : (x ...) Γ -> Γ} :
         @tt{ mk-Γ(xs, Γ)} makes a new proposition environment
         with domain @tt{xs}, knowing everything @tt{Γ} knows.}
  @item{@tt{Γ-upd : Γ Γ -> Γ} : @tt{Γ-upd(Γ1, Γ2)} updates @tt{Γ1}
         with propositions from @tt{Γ2} that refers to paths from
         @tt{Γ1}'s domain.}
  @item{@tt{dom : (ρ or Γ) -> (x ...)} : returns environment's domain.}
  @item{@tt{default-o : o (x ...) o -> o} : @tt{default-o(o1, xs, o2)}
         returns path @tt{o1} if it refers to variables in @tt{xs}
         , otherwise defaults to @tt{o2}}
]

@subsubsection{Monitored function}
Steps taken are:
evaluate @tt{c_x}, evaluate @tt{V_x}, monitor @tt{V_x},
evaluate @tt{c_y}, apply funtion, then monitor result.
@(centered (parameterize ([judgment-form-cases '("app-arr")])
             (render-judgment-form ⇓a)))
@subsubsection{Primitive operator}
@(centered (parameterize ([judgment-form-cases '("app-prim")])
             (render-judgment-form ⇓a)))

Primitive applications are where propositions are added to @tt{Γ}
@verbatim[#:indent 4]{
                      
δ : op (V o) ... Γ -> {(Ans Γ o) ...}
                      
}

@tt{δ} takes @tt{Γ} as an argument not because @tt{Γ} helps knowing more about
the arguments (they have already been fully refined at this point), but because
it needs to also return information discovered/assumed for arguments and result.
For example:
@verbatim[#:indent 4]{
                      
δ add1 (• [car z]) ([z ↦ cons?])
     = { (ERR ([z ↦ cons?] [(car z) ↦ (¬ int?)]) ∅)
         ([• int?] ([z ↦ cons?] [(car z) ↦ int?]) ∅) }
     
}
Whether argument failed or passed predicate is also remembered:
@verbatim[#:indent 4]{
                      
δ p? (V o) Γ
     = (match (prove? p? V)
        ['Proved {((#t () ()) Γ ∅)}]
        ['Refuted {((#f () ()) Γ ∅)}]
        ['Neither {((#t () ()) Γ[o ↦ p?] ∅)
                   ((#f () ()) Γ[o ↦ (¬ p?)] ∅)}])
                                                
} (@tt{Γ} only needs updating when it's ambiguous)



@subsection{Monitoring}
@verbatim[#:indent 4]{
Γ ⊢ D (V o) ⇓m Ans; Γ′
}

(@tt{Γ} and @tt{Γ′} have the same domain.)
@subsubsection{Flat contract}
@(centered (parameterize ([judgment-form-cases '("flat-ok" "flat-fail" "flat-err")])
             (render-judgment-form ⇓m)))
@subsubsection{Function contract}
@(centered (parameterize ([judgment-form-cases '("arr-ok" "arr-err")])
             (render-judgment-form ⇓m)))
@subsubsection{Disjunctive contract}
@(centered (parameterize ([judgment-form-cases '("or/c-left" "or/c-right" "or/c-err")])
             (render-judgment-form ⇓m)))
@subsubsection{Conjunctive contract}
Non-determinism and the fact that @tt{V} is already a closure
prevents me to come up with a way to turn @tt{and/c} into a nesting of
simpler tests.
@(centered (parameterize ([judgment-form-cases '("and/c" "and/c-err")])
             (render-judgment-form ⇓m)))
@subsubsection{Pair contract}
@(centered
  (parameterize
      ([judgment-form-cases '("cons/c" "cons/c-err1" "cons/c-err2" "cons/c-err3")])
             (render-judgment-form ⇓m)))
@subsubsection{Closed, unevaluated contract}
@(centered
  (parameterize ([judgment-form-cases '("closed-con" "closed-con-err")])
             (render-judgment-form ⇓m)))

@subsection{Machine semantics}

Machine state:  @(parameterize ([render-language-nts '(ς)])
                   (render-language scpcf-m))

The 4-tuple @tt{(C Γ o κ)} state means it's evaluating an expression, 3-tuple @tt{(CC Γ κ)} a contract.

The judgment form
@verbatim[#:indent 4]{
                      
Γ, ρ, O, ψ ⊢ e ⇓ Ans; Γ′; o

}
corresponds to
@verbatim[#:indent 4]{
                      
([e ρ O ψ] Γ ∅ κ) →* (Ans Γ′ o κ)

}, and
@verbatim[#:indent 4]{
                      
Γ, ρ, O, ψ ⊢ c ⇓ Dns; Γ′
                      
}
corresponds to
@verbatim[#:indent 4]{
                      
([c ρ O ψ] Γ κ) →* (Dns Γ′ κ)
                      
}, for all @tt{κ}.
 
Continuation forms
@(centered (parameterize ([render-language-nts '(κ)])
             (render-language scpcf-m)))

@itemlist[
  @item{@tt{(ap Vo* C* κ)} : waits for the next evaluated argument to be
       added to @tt{Vo*}. @tt{C*} are the next arguments to be evaluated.}
  @item{@tt{(if (C_1 o_1) (C_2 o_2) κ)} : waits to branch on either
        @tt{(C_1 o_1)} or @tt{(C_2 o_2)} depending on true/false result.}
  @item{@tt{(with-Γ Γ x* κ)} : replaces current proposition environment @tt{Γ1}
        with @tt{(Γ-upd(Γ, Γ-del(Γ1, x*)))}. Also, keeps the current path @tt{o}
        only when it's in @tt{(dom(Γ) \ x*)}}
  @item{@tt{(flat-c κ)} : waits for the expression to be evaluated then wraps it
        inside a flat contract constructor.}
  @item{@tt{(mon-e (C o) κ)} : waits for contract to be evaluated,
        then uses it to monitor closure @tt{C}}
  @item{@tt{(mon-D D κ)} : waits for expression to be evaluated,
        then uses @tt{D} to monitor it.}
  @item{@tt{(mon-C (c ρ O ψ) κ)} : waits for expression to be evaluated,
        then evaluates closed contract @tt{(c ρ O ψ)} to monitor it later}
  @item{@tt{(chk-or (V o) (or/c c_1 c_2 ρ O ψ) κ)} : waits for value
         from flat-checking @tt{c_1} on @tt{V}.
         If true, returns @tt{V} refined by @tt{c_1},
         otherwise monitors @tt{V} using @tt{c_2}.}
  @item{@tt{chk-cons} : waits for returned value, which is @tt{car V}
         then monitor @tt{(cdr V)} and returns the refined pair if
         everything succeeds.}
]

@subsubsection{On non-value: @tt{(C Γ o κ)}}
@(centered (parameterize ([render-reduction-relation-rules
                           '(var app-intro if-intro mon-intro μ e-err)])
             (render-reduction-relation red #:style 'compact-vertical)))

@subsubsection{On unevaluated contract: @tt{(CC Γ κ)}}
@(centered (parameterize ([render-reduction-relation-rules
                           '(flat/c or/c and/c cons/c func/c μ/c x/c c-err)])
             (render-reduction-relation red #:style 'compact-vertical)))

@subsubsection{On value: @tt{(V Γ o κ)}}
@(centered (parameterize ([render-reduction-relation-rules
                           '(if-true if-false mk-flat upd-Γ-2 mon
                                     app-swap app or-left or-right mon-C chk-cons)])
             (render-reduction-relation red #:style 'compact-vertical)))

@subsubsection{On evaluated contract: @tt{(D Γ κ)}}
@(centered (parameterize ([render-reduction-relation-rules
                           '(mon-swap upd-Γ-1)])
             (render-reduction-relation red #:style 'compact-vertical)))

@subsubsection{APP relation}
@verbatim[#:indent 4]{
                      
APP : V ([V o] ...) Γ κ -> (C Γ o κ)

}
@(centered (parameterize
               ([judgment-form-cases '("app-λ" "app-arr" "app-prim")])
             (render-judgment-form APP)))

@subsubsection{MON relation}
@verbatim[#:indent 4]{
                      
MON : D (V o) Γ κ -> (C Γ o κ)

}
@(centered (parameterize ([judgment-form-cases '("mon-flat")])
             (render-judgment-form MON)))
@(centered (parameterize ([judgment-form-cases '("mon-or/c")])
             (render-judgment-form MON)))
@(centered (parameterize([judgment-form-cases '("mon-and/c")])
             (render-judgment-form MON)))
@(centered (parameterize ([judgment-form-cases '("mon-cons/c-err" "mon-cons/c")])
             (render-judgment-form MON)))
@(centered (parameterize ([judgment-form-cases '("mon-arr-err" "mon-arr")])
             (render-judgment-form MON)))

@subsubsection{Preserving tail-call}

Application builds up another frame to restore @tt{Γ}'s domain later.
It's possible to compact adjacent @tt{with-Γ} frames into one.
The metafunction @tt{WITH-Γ} does this:
@verbatim[#:indent 4]{
WITH-Γ : Γ {x ...} κ -> κ
}
@(render-metafunction WITH-Γ)

@section{Appendix: metafunctions}

@subsection{dom : (ρ or Γ) -> {x ...}}
@(render-metafunction dom)

@subsection{Γ-reset : Γ x -> Γ}
@(render-metafunction Γ-reset)

@subsection{Γ-del : Γ x ... -> Γ}
@(render-metafunction Γ-del)

@subsection{Γ-mk : {x ...} Γ -> Γ}
@(render-metafunction Γ-mk)

@subsection{Γ-upd : Γ Γ -> Γ}
@(render-metafunction Γ-upd)

@subsection{default-o : o {x ...} o -> o}
@(render-metafunction default-o)