#lang scribble/lncs
@(require (only-in scribble/manual racketmod)
          slideshow/pict
          redex/pict
          (only-in "lang-simple.rkt"
                   [⇓ ⇓s] [⇓c ⇓cs] [APP APP-s] [MON MON-s] [FC FC-s] cpcf
                   AND OR)
          "lang.rkt"
          scriblib/figure)

@section{Previously problematic programs}

The system was insensitive to conditionals and relied solely
on the right disjunctive contracts for function arguments.

For example, this module worked:
@verbatim[#:indent 4]{
                      
(module
  (provide [maybe-head ((μ (list/c) (or/c nil? (cons/c any/c list/c)))
                        ↦ any/c)])
  (define (maybe-head l)
    (if (cons? l) (car l) nil)))
    
}
But this didn't:
@verbatim[#:indent 4]{
                      
(module
 (provide [maybe-head (any/c ↦ any/c)])
 (define (maybe-head l)
   (if (cons? l) (car l) nil)))
   
}
Another example is the expression generated by @tt{FC(cons/c c1 c2)} in the paper.
@verbatim[#:indent 4]{
                      
(FC (cons/c C1 C2)) = (λ (y) (and (cons? y)
                                  ((FC C1) (car y))
                                  ((FC C2) (cdr y))))     
                           
}
Also, it's useful to remember results from testing arbitrary expressions.
For example, @tt{lastpair} from the Wright paper
@verbatim[#:indent 4]{
                      
; cons? → cons?
(λ (s)
  (if (cons? (cdr s))
      (lastpair (cdr s))
      s))
      
}

@section{CPCF}
The language is mostly similar to @tt{CPCF} from the paper.
Main differences are:
@itemlist[
  @item{Type checking is skipped and terms are assumed well-typed.}
  @item{Labels are omitted when monitoring.}
  @item{Flat contract's syntax is restricted to values to avoid uninteresting details.}
]
 

@subsection{Syntax}
@(centered (parameterize
               ([render-language-nts '(e a v b op o1 o2 p? acc n c V A C ρ)])
             (render-language cpcf)))

@subsection{Expression evaluation}
@verbatim[#:indent 4]{
ρ ⊢ e ⇓ A
}
@subsubsection{Blame}
@(centered (parameterize ([judgment-form-cases '("blame")])
             (render-judgment-form ⇓s)))
@subsubsection{Value}
@(centered (parameterize ([judgment-form-cases '("val")])
             (render-judgment-form ⇓s)))
@subsubsection{Variable}
@(centered (parameterize ([judgment-form-cases '("var")])
             (render-judgment-form ⇓s)))
@subsubsection{Application}
@(centered (parameterize ([judgment-form-cases '("app" "app-err")])
             (render-judgment-form ⇓s)))
@subsubsection{Conditional}
@(centered (parameterize ([judgment-form-cases '("if-true" "if-false" "if-err")])
             (render-judgment-form ⇓s)))
@subsubsection{Monitored expression}
@(centered (parameterize ([judgment-form-cases '("mon" "mon-err-e")])
             (render-judgment-form ⇓s)))

@subsection{Contract evaluation}
@verbatim[#:indent 4]{
ρ ⊢ c ⇓c C
}
Because flat contract's syntax is restricted to values,
evaluating a contract is essentially closing values
and cannot cause blames.
@subsubsection{Flat contract}
@(centered (parameterize ([judgment-form-cases '("flat")])
             (render-judgment-form ⇓cs)))
@subsubsection{Disjunctive, conjunctive, pair, function contracts}
Function and pair contracts are delayed.
The other ones are evaluated recursively.
@(centered (parameterize ([judgment-form-cases '("func/c" "cons/c" "or/c" "and/c")])
             (render-judgment-form ⇓cs)))
@subsubsection{Recursive contract}
@(centered (parameterize ([judgment-form-cases '("μ/c")])
             (render-judgment-form ⇓cs)))

@subsection{Application}
@verbatim[#:indent 4]{
APP : V V ... -> A
}
@(centered (render-metafunction APP-s))

@subsection{Monitoring}
@verbatim[#:indent 4]{
MON : C V -> A
}
@(centered (render-metafunction MON-s))

@tt{FC} monitors a value with a flat contract,
returning @tt{#f} if value fails, @tt{non-#f} if value passes,
and may blame during evaluation.
@(centered (render-metafunction FC-s))

@(centered (render-metafunction AND))
@(centered (render-metafunction OR))

@section{Symbolic Core Racket}

@subsection{Syntax}
Compared to @tt{CPCF}, this language has symbolic values refinable by contracts.

@(centered (parameterize ([render-language-nts '(v O o o′ V C φ)])
             (render-language scpcf)))

Due to non-determinism introduced by evaluating abstract values,
metafunctions @tt{MON}, @tt{APP}, and @tt{δ} from the previous section
are turned into relations.

@verbatim[#:indent 4]{
                      
ρ, O ⊢ e ⇓  A; ρ′; o
ρ, O ⊢ c ⇓c C
APP ⊆ (ρ × V × ([V o] ...))  ×  (A × ρ′ × o)
MON ⊆ (ρ × C × (V o))  ×  (A × ρ′)
δ   ⊆ (ρ × op × ([V o] ...))  ×  (A × ρ′ × o)
         
}

@subsection{Expression evaluation}

@verbatim[#:indent 4]{
                      
ρ, O ⊢ e ⇓ A; ρ′; o

}
means expression e, closed by environment @tt{ρ},
evaluates to answer @tt{A}.
The closing environment @tt{ρ} is also refined and results
in a new environment @tt{ρ′} with the same domain and
@tt{ρ′[x]} maps @tt{x} to a value no less precise than @tt{ρ[x]}.
Further, if @tt{A} is a value and @tt{o} is not @tt{∅},
looking up @tt{ρ′} at @tt{o} gives @tt{A}.

Environment @tt{O} has the same domain as @tt{ρ},
and attempts to map each variable to a path rooted
from the lexically farthest possible variable that relates to it.
For example, in this program, by the time @tt{z} is in scope,
@tt{O} is @tt{([x ↦ (x)] [y ↦ (car x)] [z ↦ (cdr car x)])}
@verbatim[#:indent 4]{
(let [x •]
  (let [y (car x)]
    (let [z (cdr y)]
      ... )))
}


@subsubsection{Value}
@(centered (parameterize ([judgment-form-cases '("val")])
             (render-judgment-form ⇓)))

@subsubsection{Variable}
@(centered (parameterize ([judgment-form-cases '("var")])
             (render-judgment-form ⇓)))

@subsubsection{Application}
@(centered
  (parameterize 
      ([judgment-form-cases '("app-1" "app-2" "app-err-1" "app-err-2" "app-err-3")])
    (render-judgment-form ⇓)))

@subsubsection{Conditional}
@(centered (parameterize ([judgment-form-cases '("if-true" "if-false" "if-err")])
             (render-judgment-form ⇓)))

@subsubsection{Monitoring}
@(centered (parameterize ([judgment-form-cases '("mon" "mon-err")])
             (render-judgment-form ⇓)))

@subsection{Contract evaluation}
Because contract evaluation is essentially closing value,
there is no opportunity for refining the environment.
@verbatim[#:indent 4]{
                      
ρ, O ⊢ c ⇓c C

}

@subsubsection{Flat contract}
@(centered (parameterize ([judgment-form-cases '("flat")])
             (render-judgment-form ⇓c)))
@subsubsection{Function, pair, disjunctive, conjunctive contracts}
@(centered (parameterize
               ([judgment-form-cases '("func/c" "cons/c" "or/c" "and/c")])
             (render-judgment-form ⇓c)))
@subsubsection{Recursive contract}
@(centered (parameterize ([judgment-form-cases '("μ/c")])
             (render-judgment-form ⇓c)))

@subsection{Application}
@verbatim[#:indent 4]{
                      
APP ⊆ (ρ × V_f × ([V_i o_i] ...))  ×  (A × ρ′ × o)

}

Applies closure @tt{V_f} to arguments @tt{V_i}'s.
Each argument is attached with an object @tt{o_i}
that's a valid path in @tt{ρ} so @tt{ρ}
can be refined when facts are discovered/assumed about @tt{V_i}.
The refined environment @tt{ρ′} has the same domain as @tt{ρ}
and each value mapped to in @tt{ρ′} is no less precise than in @tt{ρ}.

@subsubsection{Lambda}

Precondition: if @tt{x} is in both @tt{ρ} and @tt{ρ_f}'s domains,
it refers to the same variable.

@tt{ρ-upd} updates the first environment with more precise values
from the second one.

@(centered (parameterize ([judgment-form-cases '("app-λ")])
             (render-judgment-form APP)))

@subsubsection{Monitored function}
Steps:
evaluate @tt{c_x}, monitor @tt{V_x}, apply funtion,
evaluate @tt{c_y} then monitor result.
@(centered (parameterize ([judgment-form-cases '("app-arr" "arr-err-1" "arr-err-2")])
             (render-judgment-form APP)))
@subsubsection{Primitive operator}
@(centered (parameterize ([judgment-form-cases '("app-prim")])
             (render-judgment-form APP)))

@subsubsection{Provably non-function}
@(centered (parameterize ([judgment-form-cases '("app-err")])
             (render-judgment-form APP)))

@subsubsection{Poor man's havoc}
@(centered (parameterize ([judgment-form-cases '("havoc-1" "havoc-2")])
             (render-judgment-form APP)))

@subsection{Monitoring}
@verbatim[#:indent 4]{
MON ⊆  (ρ × C × (V o))  ×  (A × ρ′)
}

@subsubsection{Flat contract}
@(centered (parameterize ([judgment-form-cases '("flat-ok" "flat-fail" "flat-err")])
             (render-judgment-form MON)))
@subsubsection{Function contract}
@(centered (parameterize ([judgment-form-cases '("func/c" "func/c-fail")])
             (render-judgment-form MON)))
@subsubsection{Disjunctive contract}
@(centered (parameterize ([judgment-form-cases '("or/c-left" "or/c-right" "or/c-err")])
             (render-judgment-form MON)))

Where @tt{FC} monitors using a flat contract like in previous section,
only it's extended as a relation.

@(centered (render-judgment-form FC))

@subsubsection{Conjunctive contract}
@(centered (parameterize ([judgment-form-cases '("and/c" "and/c-fail")])
             (render-judgment-form MON)))
@subsubsection{Pair contract}
Error can happen when the value is not a pair,
or propogated from monitoring the pair's component.
@(centered
  (parameterize
      ([judgment-form-cases '("cons/c" "cons/c-err-1" "cons/c-err-2" "cons/c-err-3")])
             (render-judgment-form MON)))

@subsection{Primitive operators}
When it's not known whether the argument satisfies or fails a condition,
both possibilities are tried out and the environment is refined
accordingly in each non-deterministic branch.
@verbatim[#:indent 4]{
                      
δ ⊆ (ρ × op × ([V o] ...))  ×  (A × ρ′ × o)
                      
}

Below is part of @tt{δ}:

@subsubsection{Primitive predicates}
@(centered
  (parameterize ([judgment-form-cases
                  '("pred-ok" "pred-fail" "pred-assume-ok" "pred-assume-fail")])
    (render-judgment-form δ)))

@subsubsection{Add1}
@tt{(∆ add1 n)} adds 1 to number @tt{n}.
I do this only because I cannot unquote inside judgment forms.
@(centered
  (parameterize ([judgment-form-cases '("add1-n" "add1-fail" "add1-assume-ok")])
    (render-judgment-form δ)))

@subsubsection{Pair accessor}
@(centered
  (parameterize ([judgment-form-cases '("car-ok" "acc-fail" "acc-assume-ok")])
    (render-judgment-form δ)))


@section{Appendix: Other metafunctions}

@subsection{Contract satisfaction}
@subsubsection{proves? : V C -> {Proved, Refuted, Neither}}
Checks whether value proves contract.
Simple adhoc rules are used for common cases.
The function defaults to the conservative answer @tt{Neither}.

@(centered (render-metafunction proves?))

@subsection{Value refining}
@subsubsection{refine : V C -> V}
Refines value with given contract.

PRECON: @tt{(proves? V C) = Neither}

POSTCON: @tt{(refine V C)} is no less precise than @tt{V}.
The function defaults to @tt{V} itself as a safe answer.

@(centered (render-metafunction refine))

@subsection{Closing value}
@subsubsection{close : v ρ O -> V}
@(centered (render-metafunction close))

@subsection{Environment manipulation}

@subsubsection{dom : ρ -> {x ...}}
@(centered (render-metafunction dom))

@subsubsection{ρ-upd : ρ_1 ρ_2 -> ρ}
Updates @tt{ρ_1[x]} to be @tt{ρ_2[x]} if @tt{x} is in both environments.

PRECON: @tt{ρ_2[x]} is no less precise than @tt{ρ_1[x]}.

@(centered (render-metafunction ρ-upd))

@subsubsection{ρ: : ρ [o ↦ φ] -> ρ}
Refines environment at path @tt{o}.

PRECON: if @tt{o} is not @tt{∅}, it's a valid path in @tt{ρ}.

@(centered (render-metafunction ρ:))

@(centered (render-metafunction V-upd))

@subsection{Path manipulation}
@subsubsection{default-o : o {x ...} o -> o}
Keeps the path if its root is in given domain,
otherwise defaults to second path.

@(centered (render-metafunction default-o))

@subsubsection{acc+ : acc o -> o}
@(centered (render-metafunction acc+))


