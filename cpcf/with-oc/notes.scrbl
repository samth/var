#lang scribble/lncs
@(require (only-in scribble/manual racketmod)
          slideshow/pict
          redex/pict
          (only-in "lang-simple.rkt"
                   [⇓ ⇓s] [⇓c ⇓cs] [APP APP-s] [MON MON-s] [FC FC-s] cpcf
                   AND OR)
          "lang1.rkt"
          scriblib/figure)

@section{Previously problematic programs}

The system was insensitive to conditionals and relied solely
on the right disjunctive contracts for function arguments.

For example, this module worked:
@verbatim[#:indent 4]{
                      
(module
  (provide [maybe-head ((μ (list/c) (or/c nil? (cons/c any/c list/c)))
                        ↦ any/c)])
  (define (maybe-head l)
    (if (cons? l) (car l) nil)))
    
}
But this didn't:
@verbatim[#:indent 4]{
                      
(module
 (provide [maybe-head (any/c ↦ any/c)])
 (define (maybe-head l)
   (if (cons? l) (car l) nil)))
   
}
Another example is the expression generated by @tt{FC(cons/c c1 c2)} in the paper.
@verbatim[#:indent 4]{
                      
(FC (cons/c C1 C2)) = (λ (y) (and (cons? y)
                                  ((FC C1) (car y))
                                  ((FC C2) (cdr y))))     
                           
}
Also, it's useful to remember results from testing arbitrary expressions.
For example, @tt{lastpair} from the Wright paper
@verbatim[#:indent 4]{
                      
; cons? → cons?
(λ (s)
  (if (cons? (cdr s))
      (lastpair (cdr s))
      s))
      
}

@section{CPCF}
The language is mostly similar to @tt{CPCF} from the paper.
Main differences are:
@itemlist[
  @item{Type checking is skipped and terms are assumed well-typed.}
  @item{Labels are omitted when monitoring.}
  @item{Flat contract's syntax is restricted to values to avoid uninteresting details.}
]
 

@subsection{Syntax}
@(centered (parameterize
               ([render-language-nts '(e a v b op o1 o2 p? acc n c V A C ρ)])
             (render-language cpcf)))

@subsection{Expression evaluation}
@verbatim[#:indent 4]{
ρ ⊢ e ⇓ A
}
@subsubsection{Blame}
@(centered (parameterize ([judgment-form-cases '("blame")])
             (render-judgment-form ⇓s)))
@subsubsection{Value}
@(centered (parameterize ([judgment-form-cases '("val")])
             (render-judgment-form ⇓s)))
@subsubsection{Variable}
@(centered (parameterize ([judgment-form-cases '("var")])
             (render-judgment-form ⇓s)))
@subsubsection{Application}
@(centered (parameterize ([judgment-form-cases '("app" "app-err")])
             (render-judgment-form ⇓s)))
@subsubsection{Conditional}
@(centered (parameterize ([judgment-form-cases '("if-true" "if-false" "if-err")])
             (render-judgment-form ⇓s)))
@subsubsection{Monitored expression}
@(centered (parameterize ([judgment-form-cases '("mon" "mon-err-e")])
             (render-judgment-form ⇓s)))

@subsection{Contract evaluation}
@verbatim[#:indent 4]{
ρ ⊢ c ⇓c C
}
Because flat contract's syntax is restricted to values,
evaluating a contract is essentially closing values
and cannot cause blames.
@subsubsection{Flat contract}
@(centered (parameterize ([judgment-form-cases '("flat")])
             (render-judgment-form ⇓cs)))
@subsubsection{Disjunctive, conjunctive, pair, function contracts}
Function and pair contracts are delayed.
The other ones are evaluated recursively.
@(centered (parameterize ([judgment-form-cases '("func/c" "cons/c" "or/c" "and/c")])
             (render-judgment-form ⇓cs)))
@subsubsection{Recursive contract}
@(centered (parameterize ([judgment-form-cases '("μ/c")])
             (render-judgment-form ⇓cs)))

@subsection{Application}
@verbatim[#:indent 4]{
APP : V V ... -> A
}
@(centered (render-metafunction APP-s))

@subsection{Monitoring}
@verbatim[#:indent 4]{
MON : C V -> A
}
@(centered (render-metafunction MON-s))

@tt{FC} monitors a value with a flat contract,
returning @tt{#f} if value fails, @tt{non-#f} if value passes,
and may blame during evaluation.
@(centered (render-metafunction FC-s))

@(centered (render-metafunction AND))
@(centered (render-metafunction OR))

@section{Symbolic Core Racket}

@subsection{Syntax}
Compared to @tt{CPCF}, this language has symbolic values refinable by contracts.
I use @tt{★} for an abstract, refinable closure instead of @tt{•}
for syntax to avoid the impression of circularity at some point.

@(centered (parameterize ([render-language-nts '(v V C ρ σ)])
             (render-language scpcf)))

Due to non-determinism introduced by evaluating abstract values,
metafunctions @tt{MON}, @tt{APP}, and @tt{δ} from the previous section
are turned into relations.

@verbatim[#:indent 4]{
                      
σ, ρ ⊢ e ⇓  A; σ
σ, ρ ⊢ c ⇓c C; σ
APP ⊆ (σ × V × [V ...])  ×  (A × σ)
MON ⊆ (σ × C × V)  ×  (A × σ)
δ   ⊆ (σ × op × [V ...])  ×  (A × σ)
         
}

@subsection{Expression evaluation}

@verbatim[#:indent 4]{
                      
σ, ρ ⊢ e ⇓  A; σ

}
means expression e, closed by environment @tt{ρ},
evaluates to answer @tt{A},
and modifies the global environment @tt{σ} to @tt{σ′}.

Environment @tt{ρ} maps variables to values as normal.
Values now include labels, which can be thought of as
pointers to some value elsewhere in the global environment @tt{σ}.
Labels are passed around like other values and are forced by @tt{APP} and @tt{δ}
when necessary.

@subsubsection{Value}
Each abstract value introduced in the source code
evaluates to a label as an alias.
@(centered (parameterize ([judgment-form-cases '("val-•" "val")])
             (render-judgment-form ⇓)))

@subsubsection{Variable}
@(centered (parameterize ([judgment-form-cases '("var")])
             (render-judgment-form ⇓)))

@subsubsection{Application}
@(centered
  (parameterize 
      ([judgment-form-cases '("app-1" "app-2" "app-err-1" "app-err-2" "app-err-3")])
    (render-judgment-form ⇓)))

@subsubsection{Conditional}
@(centered (parameterize ([judgment-form-cases '("if-true" "if-false" "if-err")])
             (render-judgment-form ⇓)))

@subsubsection{Monitoring}
@(centered (parameterize ([judgment-form-cases '("mon" "mon-err")])
             (render-judgment-form ⇓)))

@subsection{Contract evaluation}
Because contract evaluation is essentially closing value,
there is no opportunity for refining the environment.
@verbatim[#:indent 4]{
                      
σ, ρ ⊢ c ⇓c C; σ

}

@subsubsection{Flat contract}
@(centered (parameterize ([judgment-form-cases '("flat")])
             (render-judgment-form ⇓c)))
@subsubsection{Function, pair, disjunctive, conjunctive contracts}
@(centered (parameterize
               ([judgment-form-cases '("func/c" "cons/c" "or/c" "and/c")])
             (render-judgment-form ⇓c)))
@subsubsection{Recursive contract}
@(centered (parameterize ([judgment-form-cases '("μ/c")])
             (render-judgment-form ⇓c)))

@subsection{Application}
Most rules are like in previous version,
except label occuring at function position is forced.
@verbatim[#:indent 4]{
                      
APP ⊆ (σ × V_f × [V_i ...])  ×  (A × σ)

}

@subsubsection{Lambda}

@(centered (parameterize ([judgment-form-cases '("app-λ")])
             (render-judgment-form APP)))

@subsubsection{Monitored function}
Steps:
evaluate @tt{c_x}, monitor @tt{V_x}, apply funtion,
evaluate @tt{c_y} then monitor result.
@(centered (parameterize ([judgment-form-cases '("app-arr" "arr-err-1" "arr-err-2")])
             (render-judgment-form APP)))
@subsubsection{Primitive operator}
@(centered (parameterize ([judgment-form-cases '("app-prim")])
             (render-judgment-form APP)))

@subsubsection{Provably non-function}
@(centered (parameterize ([judgment-form-cases '("app-err")])
             (render-judgment-form APP)))

@subsubsection{Poor man's havoc}
@(centered (parameterize ([judgment-form-cases '("havoc-1" "havoc-2")])
             (render-judgment-form APP)))

@subsubsection{Label}
@(centered (parameterize ([judgment-form-cases '("app-l")])
             (render-judgment-form APP)))

@subsection{Monitoring}
@verbatim[#:indent 4]{
MON ⊆  (σ × C × V)  ×  (A × σ)
}

@subsubsection{Flat contract}
@(centered (parameterize ([judgment-form-cases '("flat-ok" "flat-fail" "flat-err")])
             (render-judgment-form MON)))
@subsubsection{Function contract}
@(centered (parameterize ([judgment-form-cases '("func/c" "func/c-fail")])
             (render-judgment-form MON)))
@subsubsection{Disjunctive contract}
@(centered (parameterize ([judgment-form-cases '("or/c-left" "or/c-right" "or/c-err")])
             (render-judgment-form MON)))

Where @tt{FC} monitors using a flat contract like in previous section,
only it's extended as a relation.

@(centered (render-judgment-form FC))

@subsubsection{Conjunctive contract}
@(centered (parameterize ([judgment-form-cases '("and/c" "and/c-fail")])
             (render-judgment-form MON)))
@subsubsection{Pair contract}
Error can happen when the value is not a pair,
or propogated from monitoring the pair's component.
@(centered
  (parameterize
      ([judgment-form-cases '("cons/c" "cons/c-err-1" "cons/c-err-2" "cons/c-err-3")])
             (render-judgment-form MON)))

@subsection{Primitive operators}
When it's not known whether the argument satisfies or fails a condition,
both possibilities are tried out and the global environent is refined
accordingly in each non-deterministic branch.
@verbatim[#:indent 4]{
                      
δ ⊆ (σ × op × [V ...])  ×  (A × σ)
                      
}

Below is part of @tt{δ}:

@subsubsection{Primitive predicates}
@(centered
  (parameterize ([judgment-form-cases
                  '("pred-ok" "pred-fail" "pred-l-assumed-ok" "pred-l-assumed-fail"
                              "pred-★-assumed-ok" "pred-★-assumed-fail")])
    (render-judgment-form δ)))

@subsubsection{Add1}
@tt{(∆ add1 n)} adds 1 to number @tt{n}.
I do this only because I cannot unquote inside judgment forms.
@(centered
  (parameterize ([judgment-form-cases '("add1-n" "add1-fail" "add1-assumed-ok")])
    (render-judgment-form δ)))

@subsubsection{Pair accessor}
@(centered
  (parameterize
      ([judgment-form-cases
        '("car-ok" "acc-fail" "acc-assumed-ok1" "acc-assumed-ok2")])
    (render-judgment-form δ)))


@section{Appendix: Other metafunctions}

@subsection{Contract satisfaction}
@subsubsection{proves? : σ V C -> {Proved, Refuted, Neither}}
Checks whether value proves contract.
Simple adhoc rules are used for common cases.
The function defaults to the conservative answer @tt{Neither}.

@(centered (render-metafunction proves?))

@subsection{Value refining}
@subsubsection{refine : V C -> V}
Refines value with given contract.

PRECON: @tt{(proves? V C) = Neither}

POSTCON: @tt{(refine V C)} is no less precise than @tt{V}.
The function defaults to @tt{V} itself as a safe answer.

@(centered (render-metafunction refine))

@subsection{Closing value}
@subsubsection{close : v ρ -> V}
@(centered (render-metafunction close))

@subsection{Environment manipulation}

@subsubsection{σ: : σ [l ↦ φ] -> σ}
Refines abstract value bound to label @tt{l} with proposition @tt{φ}

@(centered (render-metafunction σ:))

