#lang scribble/lncs
@(require (only-in scribble/manual racketmod)
          slideshow/pict
          redex/pict
          (only-in "lang-simple.rkt" [⇓ ⇓s] [⇓c ⇓cs] [APP APP-s] [MON MON-s] cpcf)
          "lang.rkt"
          scriblib/figure)

@section{Previously problematic programs}

The system was insensitive to conditionals and relied solely
on the right disjunctive contracts for function arguments.

For example, this module worked:
@verbatim[#:indent 4]{
                      
(module
  (provide [maybe-head ((μ (list/c) (or/c nil? (cons/c any/c list/c)))
                        ↦ any/c)])
  (define (maybe-head l)
    (if (cons? l) (car l) nil)))
    
}
But this didn't:
@verbatim[#:indent 4]{
                      
(module
 (provide [maybe-head (any/c ↦ any/c)])
 (define (maybe-head l)
   (if (cons? l) (car l) nil)))
   
}
Another example is the expression generated by @tt{FC(cons/c c1 c2)} in the paper.
@verbatim[#:indent 4]{
                      
(FC (C1 C2)) = (λ (y) (and (cons? y)
                           ((FC C1) (car y))
                           ((FC C2) (cdr y))))     
                           
}
Also, it's useful to remember results from testing arbitrary expressions.
For example, @tt{lastpair} from the Wright paper
@verbatim[#:indent 4]{
                      
; cons? → cons?
(λ (s)
  (if (cons? (cdr s))
      (lastpair (cdr s))
      s))
      
}

@section{CPCF}
The language is mostly similar to @tt{CPCF} from the paper.
Main differences are:
type checking is skipped with terms assumed well-typed,
and labels are omitted for monitoring.

The language's semantics is defined by
2 relations @tt{⇓}, @tt{⇓c}, and 2 metafunctions @tt{APP}, @tt{MON},
for expression evaluation, contract evaluation, closure application,
and closure monitoring, respectively.

@subsection{Syntax}
@(centered (parameterize
               ([render-language-nts '(e a v b op o1 o2 p? acc n c V A D Dns ρ)])
             (render-language cpcf)))

@subsection{Expression big-step semantics}
@verbatim[#:indent 4]{
ρ ⊢ e ⇓ A
}
@subsubsection{Blame}
@(centered (parameterize ([judgment-form-cases '("blame")])
             (render-judgment-form ⇓s)))
@subsubsection{Value}
@(centered (parameterize ([judgment-form-cases '("val")])
             (render-judgment-form ⇓s)))
@subsubsection{Variable}
@(centered (parameterize ([judgment-form-cases '("var")])
             (render-judgment-form ⇓s)))
@subsubsection{Application}
@(centered (parameterize ([judgment-form-cases '("app" "app-err")])
             (render-judgment-form ⇓s)))
@subsubsection{Conditional}
@(centered (parameterize ([judgment-form-cases '("if-true" "if-false" "if-err")])
             (render-judgment-form ⇓s)))
@subsubsection{Rec}
@(centered (parameterize ([judgment-form-cases '("μ")])
             (render-judgment-form ⇓s)))
@subsubsection{Monitored expressions}
@(centered (parameterize ([judgment-form-cases '("mon" "mon-err-c" "mon-err-e")])
             (render-judgment-form ⇓s)))

@subsection{Contract big-step semantics}
@verbatim[#:indent 4]{
ρ ⊢ c ⇓c Dns
}
@subsubsection{Flat contract}
@(centered (parameterize ([judgment-form-cases '("flat" "flat-err")])
             (render-judgment-form ⇓cs)))
@subsubsection{Disjunctive, conjunctive, pair, function contracts}
Disjuctive contracts are delayed because one branch may be recursive.
Cases with errors during evaluation of contracts are omitted.
@(centered (parameterize ([judgment-form-cases '("or/c" "and/c" "cons/c" "func/c")])
             (render-judgment-form ⇓cs)))
@subsubsection{Recursive contract}
@(centered (parameterize ([judgment-form-cases '("μ/c")])
             (render-judgment-form ⇓cs)))

@subsection{Application}
@verbatim[#:indent 4]{
APP : V V ... -> A
}
@(centered (render-metafunction APP-s))

@subsection{Monitoring}
@verbatim[#:indent 4]{
MON : D V -> A
}
@(centered (render-metafunction MON-s))

@section{Symbolic Core Racket}

@subsection{Syntax}
Compared to @tt{CPCF}, this language has symbolic values refinable by contracts.

@(centered (parameterize ([render-language-nts '(v φ O Γ o o′ V D)])
             (render-language scpcf)))

There is no explicit representation for union types.
Instead, non-determinism is used for better precision.
In this example from the Chugh paper,
instead of returning @tt{(∪ int? bool?)},
this function returns an @tt{int?} or @tt{bool?}
in different non-deterministic branches.
@verbatim[#:indent 4]{
                      
(λ (x)
  (cond
    [(int? x) (- 0 x)]
    [(bool? x) (false? x)])
    
}

Γ is the proposition environment, mapping each path to a set of predicates.

@verbatim[#:indent 4]{
                      
[o′ ↦ ψ1 ψ2 ...]

}
means
@verbatim[#:indent 4]{
                      
(ψ1(ρ[o′]) ∧ ψ2(ρ[o′]) ∧ ...)

}, where @tt{ρ} is the run-time environment,
and path lookup in @tt{ρ} is defined as
@verbatim[#:indent 4]{
ρ[(x)] = ρ[x] (with regular definition of variable lookup)
ρ[(acc_1 acc_2 ... x)] = acc_1(ρ[(acc_2 ... x)])
}

The language's semantics is defined by 4 relations:
@tt{⇓}, @tt{⇓c}, @tt{APP}, @tt{MON},
for expression evaluation, contract evaluation, application,
and monitoring, respectively.
Due to non-determinism introduced by evaluating abstract values,
I turn the metafunctions @tt{MON} and @tt{APP} from the previous section
into relations.

@verbatim[#:indent 4]{
                      
Γ, ρ, O ⊢ e ⇓ A; Γ′; o
Γ, ρ, O ⊢ c ⇓c D; Γ′
APP ⊆ (Γ × V × ([V o] ...))  ×  (A × Γ′ × o)
MON ⊆ (Γ × D × (V o))  ×  (A × Γ′)
         
}

@subsection{Expression big-step semantics}

@verbatim[#:indent 4]{
                      
Γ, ρ, O ⊢ e ⇓ Ans; Γ′; o

}
means under assumptions @tt{Γ}, expression @tt{e}, closed by environment @tt{ρ},
evaluates to answer @tt{A}, resulting in a new set of propositions @tt{Γ′}
with no less information than @tt{Γ}.

Invariants:
@itemlist[
  @item{@tt{dom(ρ)} = @tt{dom(O)} = @tt{dom(Γ)} = @tt{dom(Γ′)},
        where @tt{dom} is defined in Appendix.}
  @item{If @tt{A} = @tt{V} and @tt{o} ≠ @tt{∅}, then @tt{ρ[o]} is @tt{V}}
  @item{If @tt{A} = @tt{V}, whatever @tt{Γ′} knows that's relevant to @tt{V}
        has already been incorporated in @tt{V}}
]

@subsubsection{Value}
We turn propositions in @tt{Γ} into contracts refining variables
in @tt{ρ} on closing @tt{v}.
@(centered (parameterize ([judgment-form-cases '("val")])
             (render-judgment-form ⇓)))
The metafunction @tt{Γ-flush} updates @tt{ρ} with propositions from @tt{Γ}
@verbatim[#:indent 4]{
                      
Γ-flush : Γ ρ -> ρ

}
The following example illustrates why this is helpful.
This expression should always return @tt{#t}
@verbatim[#:indent 4]{
                      
(int? [(let [x •]
         (if (int? x)
             (λ (_) x)
             (λ (_) 1)))
       •])
       
}
By the time the @tt{(let ...)} part is done, all propositions on @tt{x}
will have been 'popped' out from @tt{Γ}.
We need a way to remember that @tt{x} is @tt{int?} in @tt{(λ (_) x)}.
This was not a problem with type-checking because we could look through @tt{λ}
and say it was of type @tt{(any? → int?)} once and for all.

@subsubsection{Variable}
Propositions from @tt{Γ} are used to refine values in @tt{ρ} on lookup.
For example, @tt{Γ} knows @tt{[(car x) ↦ int?]}, and @tt{x} maps to @tt{•},
then we know it evaluates to @tt{• / (cons/c int? any/c)}.
@(centered (parameterize ([judgment-form-cases '("var")])
             (render-judgment-form ⇓)))

The metafunction @tt{Γ-refine} refines @tt{x} with all relevant
propositions on @tt{O[x]}.
@verbatim[#:indent 4]{
                      
Γ-refine : V Γ o -> V

}

@subsubsection{Application}
The threading of proposition environments prevents me from making the rules more succinct
as in the previous section...
@(centered
  (parameterize 
      ([judgment-form-cases '("app-1" "app-2" "app-err-1" "app-err-2" "app-err-3")])
    (render-judgment-form ⇓)))

@subsubsection{Conditional}
@(centered (parameterize ([judgment-form-cases '("if-true" "if-false" "if-err")])
             (render-judgment-form ⇓)))

@subsubsection{Rec}
@(centered (parameterize ([judgment-form-cases '("μ")])
             (render-judgment-form ⇓)))

@subsubsection{Monitored expressions}
@(centered (parameterize ([judgment-form-cases '("mon" "mon-err-c" "mon-err-e")])
             (render-judgment-form ⇓)))

@subsection{Contract big-step semantics}
@verbatim[#:indent 4]{
                      
Γ, ρ, O ⊢ c ⇓c Dns; Γ′

}
means under assumptions @tt{Γ}, contract @tt{c},
closed by environment @tt{ρ}, evaluates to answer @tt{Dns},
resulting in a new set of propositions @tt{Γ′}
with no less information than @tt{Γ}.
The same invariant about environments' domains holds
for @tt{ρ}, @tt{O}, @tt{Γ}, @tt{Γ′}, and whatever @tt{Γ′} knows that's
relevant to @tt{D} (if @tt{Dns} = @tt{D}) has already been 'flushed'
into its environment.

@subsubsection{Flat contract}
@(centered (parameterize ([judgment-form-cases '("flat" "flat-err")])
             (render-judgment-form ⇓c)))
@subsubsection{Disjunctive, conjunctive, pair, function contracts}
(Error cases are omitted)
@(centered (parameterize
               ([judgment-form-cases '("or/c" "and/c" "cons/c" "func/c")])
             (render-judgment-form ⇓c)))
@subsubsection{Recursive contract}
@(centered (parameterize ([judgment-form-cases '("μ/c")])
             (render-judgment-form ⇓c)))

@subsection{Closure application}
@verbatim[#:indent 4]{
                      
APP ⊆ (Γ × V × ([V o] ...))  ×  (A × Γ′ × o)

}
Invariants: @tt{Γ} and @tt{Γ′} have the same domain,
and all path objects @tt{o}'s are in this domain (or @tt{∅}).

@subsubsection{Lambda}

Application is where @tt{Γ}'s domain needs maintenance
to be in sync with the new environment.
@(centered (parameterize ([judgment-form-cases '("app-λ")])
             (render-judgment-form APP)))
Metafunctions:
@itemlist[
  @item{@tt{Γ-reset : Γ x -> Γ} : extends @tt{Γ}'s domain to include @tt{x}
         , mapping it to the trivial predicate @tt{tt}.
         All previous propositions in @tt{Γ} involving paths derived from @tt{x}
         are discarded.}
  @item{@tt{Γ-del : Γ x -> Γ} : removes @tt{x} from @tt{Γ}'s domain.}
  @item{@tt{Γ-mk : (x ...) Γ -> Γ} :
         @tt{ mk-Γ(xs, Γ)} makes a new proposition environment
         with domain @tt{xs}, knowing everything @tt{Γ} knows.}
  @item{@tt{Γ-upd : Γ Γ -> Γ} : @tt{Γ-upd(Γ1, Γ2)} updates @tt{Γ1}
         with propositions from @tt{Γ2} that refers to paths from
         @tt{Γ1}'s domain.}
  @item{@tt{dom : (ρ or Γ) -> (x ...)} : returns environment's domain.}
  @item{@tt{default-o : o (x ...) o -> o} : @tt{default-o(o1, xs, o2)}
         returns path @tt{o1} if it refers to variables in @tt{xs}
         , otherwise defaults to @tt{o2}}
]

@subsubsection{Monitored function}
Steps:
evaluate @tt{c_x}, monitor @tt{V_x},
evaluate @tt{c_y}, apply funtion, then monitor result.
@(centered (parameterize ([judgment-form-cases '("app-arr")])
             (render-judgment-form APP)))
@subsubsection{Primitive operator}
@(centered (parameterize ([judgment-form-cases '("app-prim")])
             (render-judgment-form APP)))

Primitive applications are where propositions are added to @tt{Γ}
@verbatim[#:indent 4]{
                      
δ : op (V o) ... Γ -> {(Ans Γ o) ...}
                      
}

@tt{δ} takes @tt{Γ} as an argument not because @tt{Γ} helps knowing more about
the arguments (they have already been fully refined at this point), but because
it needs to also return information discovered/assumed for arguments and result.
For example:
@verbatim[#:indent 4]{
                      
δ add1 (• [car z]) ([z ↦ cons?])
     = { (blame ([z ↦ cons?] [(car z) ↦ (¬ int?)]) ∅)
         ([• int?] ([z ↦ cons?] [(car z) ↦ int?]) ∅) }
     
}
Whether argument failed or passed predicate is also remembered:
@verbatim[#:indent 4]{
                      
δ p? (V o) Γ
     = (match (prove? p? V)
        ['Proved {(#t Γ ∅)}]
        ['Refuted {(#f Γ ∅)}]
        ['Neither {(#t Γ[o ↦ p?] ∅) (#f Γ[o ↦ (¬ p?)] ∅)}])
                                                
} (@tt{Γ} only needs updating when it's ambiguous)



@subsection{Monitoring}
@verbatim[#:indent 4]{
MON ⊆  (Γ × D × (V o))  ×  (A × Γ′)
}

(@tt{Γ} and @tt{Γ′} have the same domain.)
(Some error cases are omitted)
@subsubsection{Flat contract}
@(centered (parameterize ([judgment-form-cases '("flat" "flat-fail" "flat-err")])
             (render-judgment-form MON)))
@subsubsection{Function contract}
@(centered (parameterize ([judgment-form-cases '("func/c" "func/c-fail")])
             (render-judgment-form MON)))
@subsubsection{Disjunctive contract}
@(centered (parameterize ([judgment-form-cases '("or/c-1" "or/c-2")])
             (render-judgment-form MON)))
@subsubsection{Conjunctive contract}
@(centered (parameterize ([judgment-form-cases '("and/c" "and/c-fail")])
             (render-judgment-form MON)))
@subsubsection{Pair contract}
@(centered
  (parameterize
      ([judgment-form-cases '("cons/c")])
             (render-judgment-form MON)))

@section{Appendix: metafunctions}

@subsection{dom : (ρ or Γ) -> {x ...}}
@(render-metafunction dom)

@subsection{Γ-reset : Γ x -> Γ}
@(render-metafunction Γ-reset)

@subsection{Γ-del : Γ x ... -> Γ}
@(render-metafunction Γ-del)

@subsection{Γ-mk : {x ...} Γ -> Γ}
@(render-metafunction Γ-mk)

@subsection{Γ-upd : Γ Γ -> Γ}
@(render-metafunction Γ-upd)

@subsection{default-o : o {x ...} o -> o}
@(render-metafunction default-o)