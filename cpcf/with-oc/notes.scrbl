#lang scribble/lncs
@(require (only-in scribble/manual racketmod)
          slideshow/pict
          redex/pict
          (only-in "lang-simple.rkt" [⇓ ⇓s] cpcf)
          "lang.rkt"
          "machine.rkt"
          "judgment.rkt"
          scriblib/figure)

@section{Previously problematic programs}

The system was insensitive to conditionals and relied solely
on the right disjunctive contracts for function arguments.

For example, this module worked:
@verbatim[#:indent 4]{
(module
  (provide [maybe-head ((μ (list/c) (or/c nil? (cons/c any/c list/c)))
                        ↦ any/c)])
  (define (maybe-head l)
    (if (cons? l) (car l) nil)))
}
But this didn't:
@verbatim[#:indent 4]{
(module
 (provide [maybe-head (any/c ↦ any/c)])
 (define (maybe-head l)
   (if (cons? l) (car l) nil)))
}
Another example is the expression generated by @tt{FC(cons/c c1 c2)} in the paper.
@verbatim[#:indent 4]{
(FC (C1 C2)) = (λ (y) (and (cons? y)
                           ((FC C1) (car y))
                           ((FC C2) (cdr y))))     
}
Also, it's useful to remember results from testing arbitrary expressions.
For example, @tt{lastpair} from the Wright paper
@verbatim[#:indent 4]{
; cons? → cons?
(λ (s)
  (if (cons? (cdr s))
      (lastpair (cdr s))
      s))
}

@section{CPCF}

@subsection{Language}
Labels are omitted for @tt{mon} and @tt{blame}.
Language is mostly similar to @tt{CPCF} on paper, except untyped.
@(centered (parameterize ([render-language-nts '(e v b op o1 o2 p? c ρ V A)])
             (render-language cpcf)))
(@tt{tt} is the constant true function.)

@subsection{Big-step semantics}
@verbatim[#:indent 4]{
ρ ⊢ e ⇓ V
}
@subsubsection{Value}
@(centered (parameterize ([judgment-form-cases '("val")])
             (render-judgment-form ⇓s)))
@subsubsection{Variable}
@(centered (parameterize ([judgment-form-cases '("var")])
             (render-judgment-form ⇓s)))
@subsubsection{Application}
@(centered (parameterize ([judgment-form-cases '("app-λ" "app-o1" "app-o2" "app-err")])
             (render-judgment-form ⇓s)))
@subsubsection{Conditional}
@(centered (parameterize ([judgment-form-cases '("if-true" "if-false" "if-err")])
             (render-judgment-form ⇓s)))
@subsubsection{Rec}
@(centered (parameterize ([judgment-form-cases '("μ")])
             (render-judgment-form ⇓s)))
@subsubsection{Monitored expressions}
@(centered (parameterize ([judgment-form-cases '("mon-flat")])
             (render-judgment-form ⇓s)))
@(centered (parameterize ([judgment-form-cases '("mon-func")])
             (render-judgment-form ⇓s)))
@(centered (parameterize ([judgment-form-cases '("mon-and/c")])
             (render-judgment-form ⇓s)))
@(centered (parameterize ([judgment-form-cases '("mon-or/c")])
             (render-judgment-form ⇓s)))
@(centered (parameterize ([judgment-form-cases '("mon-cons/c")])
             (render-judgment-form ⇓s)))
@(centered (parameterize ([judgment-form-cases '("mon-μ")])
             (render-judgment-form ⇓s)))
@(centered (parameterize ([judgment-form-cases '("blame")])
             (render-judgment-form ⇓s)))

@section{Symbolic Core Racket}

@subsection{Language}
Compared to @tt{CPCF}, this language has symbolic values refinable by contracts.

@(centered (parameterize ([render-language-nts '(v ψ O Γ o o′ acc C V D)])
             (render-language scpcf)))

There is no explicit representation for union types.
Instead, non-determinism is used for better precision.
In this example from the Chugh paper,
instead of returning @tt{(∪ int? bool?)},
this function returns an @tt{int?} or @tt{bool?}
in different non-deterministic branches.
@verbatim[#:indent 4]{
(λ (x)
  (cond
    [(int? x) (- 0 x)]
    [(bool? x) (false? x)])
}

Γ is the proposition environment, mapping each path to a set of predicates.

@verbatim[#:indent 4]{
[o′ ↦ ψ1 ψ2 ...]
}
means
@verbatim[#:indent 4]{
(ψ1(ρ[o′]) ∧ ψ2(ρ[o′]) ∧ ...)
}, where @tt{ρ} is the run-time environment.

@subsection{Big-step semantics}

@verbatim[#:indent 4]{
Γ, ρ, O ⊢ e ⇓ V; Γ′; o
}
means under assumptions @tt{Γ}, expression @tt{e} closed by environment @tt{ρ} evaluates to closure @tt{V}, resulting in a new set of propositions @tt{Γ′} with no less information than @tt{Γ}.

Invariants:
@itemlist[
  @item{@tt{Γ}, @tt{ρ}, @tt{O} and @tt{Γ′} have the same domain.}
  @item{if @tt{o} ≠ @tt{∅}, then @tt{ρ[o]} is @tt{V}}
  @item{Whatever @tt{Γ′} knows that's relevant to @tt{V}
        has already been incorporated in @tt{V}}
]

@subsubsection{Value}
We turn propositions in @tt{Γ} into contracts refining variables
in @tt{ρ} on closing @tt{v}.
@(centered (parameterize ([judgment-form-cases '("val")])
             (render-judgment-form ⇓)))
The metafunction @tt{flush} updates @tt{ρ} with propositions from @tt{Γ}
@verbatim[#:indent 4]{
flush : Γ ρ -> ρ
}
The following example illustrates why this is helpful.
This expression should always return @tt{#t}
@verbatim[#:indent 4]{
(int? [(let [x •]
         (if (int? x)
             (λ (_) x)
             (λ (_) 1)))
       •])
}
By the time the @tt{(let ...)} part is done, all propositions on @tt{x}
will have been 'popped' out from @tt{Γ}.
We need a way to remember that @tt{x} is @tt{int?} in @tt{(λ (_) x)}.
This was not a problem with type-checking because we could look through @tt{λ}
and say it was of type @tt{(any? → int?)} once and for all.

@subsubsection{Variable}
If @tt{x} maps to closed value @tt{V}, this is the last chance to refine it
with propositions from @tt{Γ}.
For example, @tt{Γ} knows @tt{[(car x) ↦ int?]}, and @tt{x} maps to @tt{•},
then we know it evaluates to @tt{• / (cons/c int? any/c)}.
@(centered (parameterize ([judgment-form-cases '("var")])
             (render-judgment-form ⇓)))

The metafunction @tt{refine-with-Γ} refines @tt{x} with all relevant
propositions on @tt{O[x]}.
@verbatim[#:indent 4]{
refine-with-Γ : V Γ o -> V
}

@subsubsection{Application}
λ-application is the only place where @tt{Γ}'s domain needs proper maintenance
to avoid spurious results.
@(centered (parameterize ([judgment-form-cases '("app-λ")])
             (render-judgment-form ⇓)))
Metafunctions:
@itemlist[
  @item{@tt{push : Γ x -> Γ} : extends @tt{Γ}'s domain to include @tt{x}
         ,mapping it to the trivial predicate @tt{tt}. If @tt{Γ}'s domain
         previously had a variable with the same name @tt{x},
         all old propositions are invalidated.}
  @item{@tt{pop : Γ x -> Γ} : removes @tt{x} from @tt{Γ}'s domain.}
  @item{@tt{mk-Γ : (x ...) Γ -> Γ} :
         @tt{ mk-Γ(xs, Γ)} makes a new proposition environment
         with domain @tt{xs}, knowing everything @tt{Γ} knows.}
  @item{@tt{dom : ρ -> (x ...)} : returns environment's domain.}
  @item{@tt{default-o : o (x ...) o -> o} : @tt{default-o(o1, xs, o2)}
         returns path @tt{o1} if it refers to variables in @tt{xs}
         and not refered to by @tt{o2}, otherwise defaults to @tt{o2}}
]

Assume program has been α-renamed, the only place where imprecision happens
is recursion.
It turned out this didn't hurt in all the tests and probably won't in practice.

Primitive applications are where propositions are added to @tt{Γ}.
@verbatim[#:indent 4]{
δ : op (V o) ... Γ -> {A ...}
}
@tt{δ} takes @tt{Γ} as an argument not because @tt{Γ} helps knowing more about
the arguments (they have already been fully refined at this point), but because
it needs to also return information discovered/assumed for arguments and result.
For example:
@verbatim[#:indent 4]{
δ add1 (• [car z]) ([z ↦ cons?])
     = { ERR
         ([• int?] ([z ↦ cons?] [(car z) ↦ int?]) ∅) }
}
Whether argument failed or passed predicate is also remembered:
@verbatim[#:indent 4]{
δ p? (V o) Γ
     = (match (prove? p? V)
        ['Proved {((#t () ()) Γ ∅)}]
        ['Refuted {((#f () ()) Γ ∅)}]
        ['Neither {((#t () ()) Γ[o ↦ p?] ∅)
                   ((#f () ()) Γ[o ↦ (¬ p?)] ∅)}])
} (@tt{Γ} only needs updating when it's ambiguous)

@(centered (parameterize ([judgment-form-cases '("app-o1" "app-o2")])
             (render-judgment-form ⇓)))
@(centered (parameterize ([judgment-form-cases
                           '("app-err1" "app-err2" "app-err3" "app-err4")])
             (render-judgment-form ⇓)))

@subsubsection{Conditional}
@(centered (parameterize ([judgment-form-cases '("if-true" "if-false" "if-err")])
             (render-judgment-form ⇓)))

@subsubsection{Rec}
@(centered (parameterize ([judgment-form-cases '("μ")])
             (render-judgment-form ⇓)))

@subsubsection{Monitored expressions}
@(centered (parameterize ([judgment-form-cases '("mon-flat")])
             (render-judgment-form ⇓)))
@(centered (parameterize ([judgment-form-cases '("mon-func/c")])
             (render-judgment-form ⇓)))
@(centered (parameterize ([judgment-form-cases '("mon-and/c" "mon-or/c" "mon-cons/c")])
             (render-judgment-form ⇓)))
@(centered (parameterize ([judgment-form-cases '("mon-μ")])
             (render-judgment-form ⇓)))

@subsection{Machine semantics}
Machine state:  @(parameterize ([render-language-nts '(ς)])
                   (render-language scpcf-m))

The judgment form
@verbatim[#:indent 4]{
Γ, ρ, O ⊢ e ⇓ V; Γ′; o
}
corresponds to
@verbatim[#:indent 4]{
([e ρ O] Γ ∅ κ) →* (V Γ′ o κ)
}, for all @tt{κ}.
 
Continuation forms
@(centered (parameterize ([render-language-nts '(κ)])
             (render-language scpcf-m)))
are mostly standard, with one ad-hoc/weird frame @tt{(with-Γ Γ x κ)}, which means
@emph{"update the current proposition environment into @tt{Γ} except for the ones
referring to @tt{x}.
Also, only keep the curent path @tt{o} if it refers to a variable
in @tt{Γ}'s domain that's not @tt{x}"}.

@subsubsection{On non-value}
@(centered (parameterize ([render-reduction-relation-rules
                           '(blame x app-intro if-intro μ)])
             (render-reduction-relation red #:style 'compact-vertical)))
@(centered (parameterize ([render-reduction-relation-rules
                           '(mon-flat mon-func/c mon-μ
                                      mon-and/c mon-or/c mon-cons/c)])
             (render-reduction-relation red #:style 'compact-vertical)))

@subsubsection{On value}
@(centered (parameterize ([render-reduction-relation-rules
                           '(if-true if-false app-swap β δ δ-err upd-Γ)])
             (render-reduction-relation red #:style 'compact-vertical)))

@subsubsection{Preserving tail-call}
(I'm not sure about this part yet, I might be confused ...)

The @tt{β} machine rule builds up another frame.
I try to compact adjacent @tt{with-Γ} frames to preserve tail calls
using the metafunction @tt{WITH-Γ}.
@verbatim[#:indent 4]{
WITH-Γ : Γ x κ -> κ
WITH-Γ(Γ, x, (with-Γ Γ_1 y κ)) = (with-Γ upd-Γ(Γ_1, pop(Γ, y)) x κ)
WITH-Γ(Γ, x, κ) = (with-Γ Γ x κ)
}

Unsure if it was safe to do so,
I checked whether @tt{upd-Γ} was associative,
meaning was it true that:
@verbatim[#:indent 4]{
upd-Γ(upd-Γ(Γ_1, Γ_2), Γ_3) = upd-Γ(Γ_1, upd-Γ(Γ_2, Γ_3))
}

It turned out that it was not associative.
It was @emph{better} than associative.

Let @tt{Γ_l} = @tt{LHS}, @tt{Γ_r} = @tt{RHS}.
In both cases, the environment's domain is that of @tt{Γ_1},
by @tt{upd-Γ}'s definition.

Then for all paths @tt{o} in @tt{Γ_1}'s domain:
@verbatim[#:indent 4]{
Γ_r[o] = Γ_3[o], if o ∈ (dom(Γ_3) ∩ dom(Γ_2) ∩ dom(Γ_1))
         Γ_2[o], if o ∈ (dom(Γ_2) ∩ dom(Γ_1))
         Γ_1[o], otherwise
}
@verbatim[#:indent 4]{
Γ_l[o] = Γ_3[o], if o ∈ (dom(Γ_3) ∩ dom(Γ_1))
         Γ_2[o], if o ∈ (dom(Γ_2) ∩ dom(Γ_1))
         Γ_1[o], otherwise
}

@tt{Γ_l} has a chance no worse than @tt{Γ_r} for using the most precise
proposition from @tt{Γ_3}.

@tt{Γ_r} is what happens naturally when we adjust the environment's
domain before returning. @tt{Γ_l} is what happens when we have the explicit
stack representation and compact frames along the way.
When @tt{upd-Γ} associates to the right, a proposition @tt{ψ(o)} in @tt{Γ_n} only
make its way back to @tt{Γ_1} when @tt{o} is in the domains of all environments
@tt{1} through @tt{n}.
When @tt{upd-Γ} associates to the left, the path @tt{o} needs only be common
to @tt{Γ_1} and @tt{Γ_n}.
By trying to preseve tail-calls, we accidentally improve precision a bit
by also preserving the set of variables/paths we're interested in.