#lang scribble/lncs
@(require (only-in scribble/manual racketmod)
          slideshow/pict
          redex/pict
          "lang.rkt"
          "machine.rkt"
          "judgment.rkt"
          scriblib/figure)

@section{Previously problematic programs}

Basically programs not guided by appropriate disjunctive contracts.

@verbatim[#:indent 4]{
(module
 (provide
  [f (any/c ↦ any/c)])
 (define (f x)
   (if (cons? x) (car x) x)))
}

Another example is the expression generated by @tt{FC(cons/c c1 c2)} in the paper.

@verbatim[#:indent 4]{
(FC (C1 C2)) = (λ (y) (and (cons? y)
                           ((FC C1) (car y))
                           ((FC C2) (cdr y))))
}

@section{Language}

Similar to @tt{S-CPCF} from paper.

@(centered (render-language scpcf))

There is no explicit representation for union types.
Instead, non-determinism is used for better precision.
One example to illustrate this is from the Chugh paper.
Instead of returning @tt{(∪ int? bool?)},
this function returns an @tt{int?} or @tt{bool?}
in different non-deterministic branches.

@verbatim[#:indent 4]{
(λ (x)
  (cond
    [(int? x) (- 0 x)]
    [(bool? x) (false? x)])
}

Γ is the proposition environment, mapping each path to a set of predicates.
@tt{[o ↦ ψ1 ψ2 ...]} means @tt{((ψ1 o) ∧ (ψ2 o) ∧ ...)}.

@section{Big-step semantics}

@(centered (render-judgment-form ⇓))

@section{Machine semantics}

@(centered (render-reduction-relation red))

@section{Appendix: metafunctions}