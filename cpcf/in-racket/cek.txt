expression:
E = A
    X
    E E
    μ. E
    if E E E
    o E ...
    mon h f g C E
A = V
    blame f h
V = U Cs
U = λ. E
    numbers
    #t #f
    nil
    (• T)
    
contract:
C = flat E
    C ↦ λ.C
    cons/c C C
    C ∨ C
    C ∧ C
    μ. C
    X
    
closure:
Cl = ExpClo <E Env>
     MonFnClo <L L L ConCl Cl>
     ConsClo <Cl Cl>
     
kontinuation:
κ = Mt
    Ar Cl κ
    Fn Cl κ ; where Cl = <V, ρ>
    If Cl1 Cl2 κ
    O o [V ...] [E ...] ρ κ
    Mon h f g ConCl κ
    ChkCdr h f g ConCl Cl κ
    ChkOr Cl ConCl1 h f g ConCl2 κ

step cek:
let (Cl, κ) ≡ cek:
if Cl ≡ (E, ρ) where E ≠ V:
    case E of:
        X ↦ (Cl', κ), where Cl' = ρ[X]
        blame f h ↦ ((blame f h, ∅), Mt)
        E1 E2 ↦ ((E1, ρ), Ar (E2, ρ), κ)
        μ. E ↦ ((E, ρ:(μ. E, ρ)), κ)
        if E1 E2 E3 ↦ ((E1, ρ), If (E2, ρ) (E3, ρ) κ)
        o E1 E2... ↦ ((E1, ρ), O o [] [E2...] ρ κ)
        mon h f g C E ↦ ((E, ρ), Mon h f g (C, ρ) κ)
else: ;; E ≡ V, or Cl ≡ MonFnClo, or Cl ≡ ConsClo
    case κ of:
        Mt ↦ cek
        Ar Cl' κ ↦ (Cl', Fn Cl κ)
        Fn Cl' κ ↦ case Cl' of:
                      (λ. E, ρλ) ↦ ((E, pλ:Cl), κ)
                      ((• (Tx → Ty)) Cs, ρλ)
                            ↦ (((• Ty)/{(C2, ρc:Cl), for (C1 ↦ λ.C2) ∈ Cs}, ∅), κ)
                            ↦ ((havoc Tx, ∅), Ar Cl κ)
                      MonFnClo h f g (C1 ↦ λ.C2, ρc) Cl'
                            ;; break MonFn into 3 simpler frames
                            ↦ (Cl, Mon h g f C1 ρc ; monitor argument
                                   (Fn Cl' ; apply function
                                   (Mon h f g C2 ρ:Cl κ))) ; monitor result
        If Cl1 Cl2 κ ↦ (Cl1, κ) , if #t ∈ δ(true?, Cl)
                     ↦ (Cl2, κ) , if #f ∈ δ(true?, Cl)
        O o [Vn...V1] [] ρ κ ↦ ((δ o [V1...Vn], ∅), κ)
        O o [Vm-1...V1] [Em+1...En] ρ κ
                ↦ ((Em+1, ρ), O o [Cl-val, Vm-1...V1] [Em+2...En] ρ κ)
        Mon h f g (C, ρc) κ ↦
            case (maybe-flatten C) of:
               Just p ↦
                   case (verify Cl (C, ρc)) of:
                       Proved ↦ (Cl, κ)
                       Refuted ↦ ((blame f h, ∅), Mt)
                       Neither ↦ ((p, ρc), Ar Cl
                                           (If (Cl · (C, ρc)) (blame f h, ∅) κ))
               Nothing ↦
                   case C of:
                       (C1 ↦ λ.C2) ↦ (MonFnClo h f g ConCl Cl, κ)
                       cons/c C1 C2 ↦
                           let car_cdr ← split-cons Cl ; non-deterministic
                           in case car_cdr of:
                                (Cl1, Cl2) ↦ (CL1, Mon h f g (C1, ρc)
                                                   (ChkCdr h f g (C2, ρc) Cl2 κ))
                                _          ↦ ((blame f h, ∅), Mt)
                       C1 ∨ C2 ↦ ((FC(C1), ρc), Ar (Cl, ρc)
                                                (ChkOr Cl (C1, ρc)
                                                       h f g (C2, ρc) κ))
                       C1 ∧ C2 ↦ (Cl, Mon h f g (C1, ρc)
                                          (Mon h f g (C2, ρc) κ))
                       μ. C' ↦ (MonFnClo h f g (C', ρc:C) Cl, κ)
                       X ↦ (Cl, Mon h f g (C',ρ') κ), where (C',ρ') = ρc[X]
        ChkCdr h f g (C, ρc) Cl1 κ ↦ (Cl1, Mon h f g (C, ρc)
                                           (Op cons [Cl] [] κ))
        ChkOr Cl1 ConCl1 h f g ConCl2 κ
                   ↦ (Cl1 · ConCl1, κ), if #t ∈ δ(true?, Cl)
                   ↦ (Cl1, Mon h f g ConCl2 κ), if #f ∈ δ(true?, Cl)